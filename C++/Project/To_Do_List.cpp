#include <iostream>
#include <fstream>

using std::cin;
using std::cout;
using std::endl;
using std::string;

string getToDoWork();

class Node
{
    string list;
    Node *next;

public:
    Node() {}
    Node(string work) : list(work), next(nullptr) {}

    string returnValue()
    {
        return list;
    }

    void setNext(Node *nextNode)
    {
        next = nextNode;
    }

    Node *returnNext()
    {
        return next;
    }
};

class linkedList_for_ToDoList
{
    Node *head;

public:
    linkedList_for_ToDoList() : head(nullptr) {}

    // Inseting values at the beginning of the list
    void insert(string &value) // Passing by reference is great for this coz a string is a large value and if I use pass by value then it will make a copy of it which means it is inefficient in terms of memory as well as time
    {
        // string value = getToDoWork();
        Node *newnode = new Node(value);
        newnode->setNext(head);
        head = newnode;
        cout << " \" " << value << " \" inseted successfully!" << endl;
        putIntoFile(value);
    }

    // Displaying the values in each node
    void display()
    {
        Node *temp_ptr = head;

        while (temp_ptr != nullptr)
        {
            cout << temp_ptr->returnValue() << endl;
            temp_ptr = temp_ptr->returnNext();
        }
    }

    // Storeing the data inside a file
    void putIntoFile(string &value)
    {
        std::fstream file;
        file.open("To Do List.txt", std::ios::app);

        if (!file)
        {
            std::cerr << "\nUnable to create and write inside the file!!" << endl;
            return;
        }

        else
        {
            static int count = 0;
            file << ++count << ". " << value << endl;
        }

        file.close();
    }

    // Destructor and releasing memory
    ~linkedList_for_ToDoList()
    {
        Node *current = head;
        while (current != nullptr)
        {
            Node *nextnode = current->returnNext();
            delete current;
            current = nextnode;
        }
    }
};

// Get the list of to do list
string getToDoWork()
{
    string work;
    cout << "\nEnter the to do work: ";
    getline(cin, work);
    return work;
}

int main()
{
    char ch;
    linkedList_for_ToDoList l;
    while (true)
    {
        cout << "\nDo you want to insert any new to do work? (y/n)? " << endl;
        cin >> ch;

        cin.ignore();
        if (ch == 'y' || ch == 'Y')
        {
            string value = getToDoWork();
            l.insert(value);
        }

        else
            break;
    }

    cout << "\nDo you wanna see your list: ";
    cin >> ch;

    cin.ignore();
    if (ch == 'y' || ch == 'Y')
    {
        l.display();
    }
    return 0;
}

/*
||||||NOTE||||||
In C++, we cannot assing a new value to a return value of a function.
eg:
if I make a function inside Node class as:
Node* returnNext()
{
    return next;
}
and then inside linkedList class:
void insert()
{
    Node * newnode = head;
    newnode->returnNext()=head; //ERRORRRR
    // I can't do this coz C++ don't allow me to modify return value of a function
    // Here I'm modifying it so I can't do this
    // when we call newnode->returnNext(), it returns the current vlaue of next pointer, but
       it does not give us a way to assign a new value to that pointer. i.e., it allows us to read the
       next pointer, not modify it
        So here returnNext() functino serves a s a GETTER for the next pointer. Its purpose is just
        to allow other parts of my code to access the next node without modifying it.
        Now we use SETTER Method to modify the value of next pointer as above.
}
*/

/*

WHY WE USED cin.ignore()???

Understanding cin and Input Buffers

    1.	Input Buffer: When you use cin, it reads input from the standard input (usually the keyboard) into an internal buffer.
    This buffer holds the input until your program processes it.
    2.	Newline Character: When you input a value (like a character or a number) and press Enter, the cin function reads the
    value, but the newline character (\n) generated by pressing Enter remains in the buffer.

Why cin.ignore() is Necessary

When you call getline(), it reads input until it encounters a newline character. If there is a newline left in the buffer from
a previous cin call, getline() will immediately read that newline and consider it as an empty string.


*/
